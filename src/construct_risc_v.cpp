#include "construct_risc_v.hpp"

// Constructs Risc-V assembly command to binary code by reading file and output
//     if_name_ is the input file name
//     of_name_ is the output file name
bool Ctor_RV::rv_assembly0_to_bin(std::string if_name_, std::string of_name_) {

    bool no_error{true};

    // For error checking usage
    unsigned long count{1};

    // Attempt to open input and output file
    std::ifstream fin(if_name_);
    std::ofstream fout(of_name_);
    
    // Check if the input file failed to open
    if(!fin.is_open()) {
        std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
        std::cout << "Error opening the input file: " << if_name_ << "." << std::endl;
        return false;
    }
    // Check if the output file failed to open
    if(!fout.is_open()) {
        std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
        std::cout << "Error opening the output file: " << of_name_ << "." << std::endl;
        return false;
    }

    std::string cur_line;
    std::getline(fin, cur_line);

    // Check if the risc-v assembly file is of the correct type
    if(!Utility::is_start_with(cur_line, "Scode Assembly 0")) {
        std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
        std::cout << "Input file has the wrong type: " << if_name_ << "." << std::endl;
        return false;
    }

    // Output the scode header
    fout << "Scode Binary, Generated By Ctor_RV." << std::endl;

    // Access all element of the file
    while(std::getline(fin, cur_line)) {

        count++;

        std::string inst;

        int rd, rs1, rs2;       // reg inputs
        int imm;                // immediate


        std::pair<Word, int> generate_output;

        // Construct the string stream to access all elements on the line
        std::stringstream ss_line(cur_line);
        
        // Read the instruction
        ss_line >> inst;

        // Attempt to find the instruction in map
        auto it = Utility::rv_inst.find(inst);

        if(it != Utility::rv_inst.end()) {
            int inst_code = it->second;

            switch (inst_code) {
            case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: // Case R Type Instructions
                // Input rd, rs1, rs2 and generate code
                if(ss_line >> rd >> rs1 >> rs2) {
                    switch (inst_code) {
                    case 0: // case add
                        generate_output = Gen_Code::ADD(rd, rs1, rs2);
                        break;
                    case 1: // case sub
                        generate_output = Gen_Code::SUB(rd, rs1, rs2);
                        break;
                    case 2: // case xor
                        generate_output = Gen_Code::XOR(rd, rs1, rs2);
                        break;
                    case 3: // case or
                        generate_output = Gen_Code::OR(rd, rs1, rs2);
                        break;
                    case 4: // case and
                        generate_output = Gen_Code::AND(rd, rs1, rs2);
                        break;
                    case 5: // case sll
                        generate_output = Gen_Code::SLL(rd, rs1, rs2);
                        break;
                    case 6: // case srl
                        generate_output = Gen_Code::SRL(rd, rs1, rs2);
                        break;
                    case 7: // case sra
                        generate_output = Gen_Code::SRA(rd, rs1, rs2);
                        break;
                    case 8: // case slt
                        generate_output = Gen_Code::SLT(rd, rs1, rs2);
                        break;
                    case 9: // case sltu
                        generate_output = Gen_Code::SLTU(rd, rs1, rs2);
                        break;
                    }
                    if(generate_output.second == 0) {
                        fout << generate_output.first << std::endl;
                    } else {
                        fout << "!!! Error line !!!" << std::endl;
                        std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
                        Error_Out::out_error(generate_output.second, count, "");
                        no_error = false;
                    }
                } else {
                    fout << "!!! Error line !!!" << std::endl;
                    std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
                    Error_Out::out_error(102, count, "R Type Instruction should have format: \"cmd rd rs1 rs2\".");
                    no_error = false;
                }
                break;

            case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18:
            case 19: case 20: case 21: case 22: case 23: // Case I type instructions (1st part)
                // Input rd, rs1, imm and generate code
                if(ss_line >> rd >> rs1 >> imm) {
                    switch (inst_code) {
                    case 10: // case addi
                        generate_output = Gen_Code::ADDI(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 11: // case xori
                        generate_output = Gen_Code::XORI(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 12: // case ori
                        generate_output = Gen_Code::ORI(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 13: // case andi
                        generate_output = Gen_Code::ANDI(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 14: // case slli
                        generate_output = Gen_Code::SLLI(rd, rs1, Utility::change_length_unsigned(imm, 5));
                        break;
                    case 15: // case srli
                        generate_output = Gen_Code::SRLI(rd, rs1, Utility::change_length_unsigned(imm, 5));
                        break;
                    case 16: // case srai
                        generate_output = Gen_Code::SRAI(rd, rs1, Utility::change_length_unsigned(imm, 5));
                        break;
                    case 17: // case slti
                        generate_output = Gen_Code::SLTI(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 18: // case sltiu
                        generate_output = Gen_Code::SLTIU(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    
                    case 19: // case lb
                        generate_output = Gen_Code::LB(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 20: // case lh
                        generate_output = Gen_Code::LH(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 21: // case lw
                        generate_output = Gen_Code::LW(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 22: // case lbu
                        generate_output = Gen_Code::LBU(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    case 23: // case lhu
                        generate_output = Gen_Code::LHU(rd, rs1, Utility::change_length(imm, 12));
                        break;
                    }
                    
                    if(generate_output.second == 0) {
                        fout << generate_output.first << std::endl;
                    } else {
                        fout << "!!! Error line !!!" << std::endl;
                        std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
                        Error_Out::out_error(generate_output.second, count, "");
                        no_error = false;
                    }
                } else {
                    fout << "!!! Error line !!!" << std::endl;
                    std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
                    Error_Out::out_error(102, count, "I Type Instruction should have format: \"cmd rd rs1 imm\".");
                    no_error = false;
                }
                break;

            case 27: // case beq
                // Input rs1_, rs2, imm and generate code
                if(ss_line >> rs1 >> rs2 >> imm) {
                    generate_output = Gen_Code::BEQ(rs1, rs2, Utility::change_length(imm, 12));
                    if(generate_output.second == 0) {
                        fout << generate_output.first << std::endl;
                    } else {
                        fout << "!!! Error line !!!" << std::endl;
                        std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
                        Error_Out::out_error(generate_output.second, count, "");
                        no_error = false;
                    }
                } else {
                    fout << "!!! Error line !!!" << std::endl;
                    std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
                    Error_Out::out_error(102, count, "Command \"beq\" should have format: \"beq rs1 rs2 imm\".");
                    no_error = false;
                }
                
            default:
                break;
            }

        } else {
            fout << "!!! Error line !!!" << std::endl;
            std::cout << "Error constructing rv assembly 0 to binary." << std::endl;
            Error_Out::out_error(101, count, inst);
            no_error = false;
        }

    }

    return no_error;

}
